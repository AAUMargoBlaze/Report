The most visible part of any language is its syntax.

In this section we will try to reach a conclusion for what operations we would like to implement and the syntax
that we believe they should be represented by.

Our end goal will be to have a guideline for what operations are represented as, though they may have to be tweaked
during implementation if we find issues.

\bigskip

\noindent
When defining syntax we try to keep the following in mind:

\noindent
\textbf{Popularity} \- \textit{do other languages use this notation?}

If the notation is already popular then it will be less confusing for experienced programmers to learn

\noindent
\textbf{Verbosity} \- \textit{how obvious is the operator?}

If we create notation that doesn't feel natural, it might lead to a lot of unnecessary documentation reading

\noindent
\textbf{Obscurity} \- \textit{is the operator too similar to existing operators?}

If so, programmers may be confused what is occurring in existing code, causing it to take longer to debug

\subsection{Ambigouty in Ownership and Operation}
context vs explicit operations.

\subsection{Assignment and Types}
The most simple operation we can perform is assignment, as we have chosen to build a strongly typed language, we will
specify explicit definitions using the popular {type} {var_name} = {value}

\subsection{Branching}
if else

\subsection{Graphs}
include inheritance option.

\subsection{Nodes}
ref and clone and immutability.


\subsection{Unique Operators}
why we agree these obscure operators are fair tradeof

\subsection{Edges}
operators on edges.
rel keyword.
terms
TODO: decide if you're happy with this order


\subsection{Iteration}
while + fmap

\subsection{Polymorphic Implications}
runtime checks, var and node operations.

\subsection{Semantic Ambigouities Arising From the Syntax}
Insert some examples here from the discussion.