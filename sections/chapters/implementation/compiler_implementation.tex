This section will cover the internal logic of the compiler.

\subsection{Listeners}

\subsection{Exceptions}

\subsection{Testing}
To ensure that our compiler functions correctly we must construct a test suite that ensures valid lattice code compiles
correctly, and that invalid lattice code is appropriately handled.
Exhaustively testing language features is unsolvable, and language components are too interoperable to realistically
construct unit tests (no language components will realistically exist in a vacuum).
Our approach will largely involve focusing on target code snippets and matching them to concrete examples - this will
allow us to build regression tests to ensure that language changes do not affect established working code.
The unfortunate effect of this approach is that it leaves code open unexpected exploitations, our only defence against
this will be to attempt to create tests that logically could expose flaws (heuristically based on personal experience).

In reality there are no other realistic options to approach testing a language, as no algorithm exists to ensure the
validity of one.
We can see examples of this becoming an issue in more mature languages such as Python~\cite{PythonIssue} - with this
knowledge our goal would be to foster and leverage a community, then act quickly once issues are brought up.

In this section we will cover the test cases that we have chosen, and our reasons for having them.

\subsection{Distribution}
Our last task is to ensure that end users are capable of conveniently executing the code we have provided.
Leveraging the use of libraries helps us streamline the process, but also introduces steps that an end user would have
to follow.
Ideally our implementation would execute directly without many requirements, however, without having a clear way to do
that we have decided to settle on using a Docker image as an executable~\cite{DockerExec}, which will limit the usage
requirements to just running docker.

Unfortunately the nature of graphviz visualisations rely on specific subsystems to provide an image on screen, naturally
these subsystems do not communicate with those of the host machine without tweaking, which would defeat the purpose of
using docker for convenience.
Rather than attempt a complex solution, we have decided to rely on the ``libgraph-easy-perl'' package, which can
translate dot notation to ascii form - this can then be printed to standard out.

\begin{lstlisting}[caption={The DockerFile used for distribution},captionpos=b,label={lst:dockerfile}]
    FROM python:3.9

    RUN pip install graphviz
    RUN pip install lattice-graph-manipulation
    RUN apt update
    RUN apt install -y graphviz
    RUN apt install -y xdg-utils
    RUN apt install -y libgraph-easy-perl

    ENTRYPOINT ["python"]
\end{lstlisting}

We can now simply use environment variables to ensure that the text version is printed for distributed versions of
the application.
